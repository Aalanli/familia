use std::str::FromStr;
use crate::ast::{Loc, Ident, Tok, LexError};
use crate::ast::{
    Expr, ExprKind, 
    Stmt, StmtKind, 
    Decl, DeclKind, 
    AST, 
    Type, TypeKind, 
    Var, 
    P, 
    Path,
    self
};


grammar;

pub AST : AST = {<d:Decl*> => AST { decls: d }, }

pub Decl : Decl = {
    <lloc:@L> "type" <name:Ident> "=" <decl:Type> <rloc:@L> => {
        let kind = DeclKind::TypeDecl { name, decl };
        Decl { kind, span: lloc.span(rloc) }
    },
    <decl:FnDecl> => decl,
    <lloc:@L> <decl:FnDecl> <body:StmtBody> <rloc:@L> => {
        let DeclKind::FnDecl { name, args, ty } = decl.kind else { unreachable!() };
        let kind = DeclKind::FnImpl {
            name, args, ty, body
        };
        Decl { kind, span: lloc.span(rloc) }
    }
}

pub FnDecl : Decl = {
    <lloc:@L> "fn" <name:Ident> "(" <args:Comma<Var>> ")" <tlloc:@L> <ret:(":" <Type>)?> <rloc:@L> => {
        let temp_void = Type { kind: TypeKind::Void, span: tlloc.span(rloc) };
        let kind = DeclKind::FnDecl {
            name, args, ty:ret.map_or(temp_void, |x| x)
        };
        Decl { kind, span: lloc.span(rloc) }
    }
}

pub StmtBody: Vec<Stmt> = {
    "{" <stmts:Stmt*> "}" => stmts,
}

pub Stmt : Stmt = {
    <lloc:@L> <kind:StmtKind> <rloc:@L> => Stmt { kind, span: lloc.span(rloc) },
}

StmtKind: StmtKind = {
    "let" <v:Var> "=" <e:Expr> ";" => StmtKind::LetStmt { var:v, expr:e },
    <e:Expr> ";" => StmtKind::ExprStmt { expr:e },
//    <lhs:UnTypedVar> "=" <rhs:Expr> ";" => StmtKind::AssignStmt { lhs, rhs },
    "return" <expr:Expr> ";" => StmtKind::ReturnStmt { expr } 
}

pub Expr : Expr = {
    <lloc:@L> <kind:ExprKind> <rloc:@L> => {
        Expr { kind, span: lloc.span(rloc) }
    },
}

ExprKind: ExprKind = {
    <n:Int> => ExprKind::IntLit(n),
    <v:Var> => ExprKind::Var(v),
    <e:Expr> "." <a:Ident> => ExprKind::GetAttr { exp: P(e), sym: a },
    "(" <l:Expr> "+" <r:Expr> ")" => ExprKind::Add { lhs:P(l), rhs:P(r) },
    <c:Path> "(" <args:Comma<Expr>> ")" => ExprKind::Call { path:c, args },
    "{" <args:Comma<(<Ident> ":" <Expr>)>> "}" => ExprKind::Struct { args },
}

pub Type : Type = {
    <lloc:@L> <kind:TypeKind> <rloc:@L> => {
        Type { kind, span: lloc.span(rloc) }
    },
}

TypeKind: TypeKind = {
    "i32" => TypeKind::I32,
    "{" <fields:Comma<TypeVar>> "}" => {
        TypeKind::Struct { fields }
    },
    <s:Path> => TypeKind::Symbol(s)
}

pub Path: Path = {
    <lloc:@L> <mut v:(<Ident> "::")*> <e:Ident> <rloc:@L> => {
        v.push(e);
        Path { path: v, span: lloc.span(rloc) }
    }
}

pub Var: Var = {
    <v:UnTypedVar> => v,
    <v:TypeVar> => v
}

UnTypedVar : Var = <lloc:@L> <v:Ident> <rloc:@L> => Var { name : v, ty: None, span: lloc.span(rloc) };
TypeVar : Var = <lloc:@L> <v:Ident> ":" <t:Type> <rloc:@L> => Var { name: v, ty: Some(t), span: lloc.span(rloc) };


Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


extern {
    type Location = Loc;
    type Error = LexError;

    enum Tok {
        "i32" => Tok::I32,
        "class" => Tok::Class,
        "type" => Tok::Type,
        "fn" => Tok::Fn,
        "let" => Tok::Let,
        "return" => Tok::Return,
        "+" => Tok::Plus,
        "=" => Tok::Equal,
        "." => Tok::Dot,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        ":" => Tok::Colon,
        "::" => Tok::ColonAcc,
        ";" => Tok::SemiColon,
        "," => Tok::Comma,
        Ident => Tok::Ident(<Ident>),
        Int => Tok::Int(<i32>)
    }
}